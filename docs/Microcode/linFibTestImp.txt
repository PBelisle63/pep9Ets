//Micro von Neumann cycle implementation

//First, decide if the program counter is even, and pick the appropriate fetch logic
1. start: if ISPCE uvnc_even else uvnc_odd

// Path taken for even instruction fetch
2. uvnc_even: A=6, B=7, MARMux=1; MARCk
// Initiate fetch, PC <- PC + 1.
3. MemRead, A=7, B=23, AMux=1, ALU=1, CMux=1, C=7; SCk, LoadCk
4. MemRead, A=6, B=22, AMux=1, CSMux=1, ALU=2, CMux=1, C=6; LoadCk
5. MemRead, MDREMux=0, MDROMux=0; MDRECk, MDROCk
// IR <- MDREven, T1 <- MDROdd.
6. EOMux=0, AMux=0, ALU=0, CMux=1, C=8; LoadCk
7. EOMux=1, AMux=0, ALU=0, CMux=1, C=11; LoadCk; goto end_is_fetch


//Path taken for odd instruction fetch IR <- T1
8. uvnc_odd: if ISPREFETCHVALID unvc_odd_v else unvc_odd_i
//Path taken when prefetch is valid
9. unvc_odd_v:A=11, AMux=1, ALU=0, CMux=1, C=8; LoadCk
// PC <- PC plus 1.
10. A=7, B=23, AMux=1, ALU=1, CMux=1, C=7; SCk, LoadCk
11. A=6, B=22, AMux=1, CSMux=1, ALU=2, CMux=1, C=6; LoadCk
//Path taken when prefetch is not valid
// Initiate fetch, PC <- PC + 1.
12. unvc_odd_i: A=6, B=7, MARMux=1; MARCk
13. MemRead, A=7, B=23, AMux=1, ALU=1, CMux=1, C=7; SCk, LoadCk
14. MemRead, A=6, B=22, AMux=1, CSMux=1, ALU=2, CMux=1, C=6; LoadCk
15. MemRead, MDREMux=0, MDROMux=0; MDRECk, MDROCk
// IR <- MDREven, T1 <- MDROdd.
16. EOMux=1, AMux=0, ALU=0, CMux=1, C=8; LoadCk
//Either begin executing a unary instruction, OR fetch the OS of a non-unary instruction.
17. end_is_fetch: if ISUNARY unary_dispatch else nonunary_fetch


//For a non-unary instruction, branch depending on if the PC is even
18. nonunary_fetch: if ISPCE nuf_even else nuf_odd
19. nuf_even: A=6, B=7, MARMux=1; MARCk
// Initiate fetch, PC <- PC + 2.
20. MemRead, A=7, B=24, AMux=1, ALU=1, CMux=1, C=7; SCk, LoadCk
21. MemRead, A=6, B=22, AMux=1, CSMux=1, ALU=2, CMux=1, C=6; LoadCk
22. MemRead, MDREMux=0, MDROMux=0; MDRECk, MDROCk
// OS <- MDREven & MDROdd
23. EOMux=0, AMux=0, ALU=0, CMux=1, C=9; LoadCk
24. EOMux=1, AMux=0, ALU=0, CMux=1, C=10; LoadCk; AMD //Decode the value of the addressing mide

// PC <- PC +2.
25. nuf_odd: A=7, B=24, AMux=1, ALU=1, CMux=1, C=7; SCk, LoadCk
26. A=6, B=22, AMux=1, CSMux=1, ALU=2, CMux=1, C=6; LoadCk
//Initiate fetch.
27. A=6, B=7, MARMux=1; MARCk
//OS<hi> <- T1.
28. MemRead, A=11, AMux=1, ALU=0, CMux=1, C=9; LoadCk
29. MemRead
30. MemRead, MDREMux=0, MDROMux=0; MDRECk, MDROCk
// OS<lo> <- MDREven, T1 <- MDROdd.
31. EOMux=0, AMux=0, ALU=0, CMux=1, C=10; LoadCk
32. EOMux=1, AMux=0, ALU=0, CMux=1, C=11; LoadCk

33. unary_dispatch:a=5;  ISD //Start the unary execution path

//*****************
//
// Operand Specifier decoder
//
//*****************
34. iAddr: A=9, AMux=1, ALU=0, CMux=1, C=20; LoadCk
35. A=10, AMux=1, ALU=0, CMux=1, C=21; LoadCk;  ISD

//Direct Addressing Modes (D, S, X, SX)
36. dAddr: A=9, B=10, MARMux=1; MARCk
37. MemRead, A=10, AMux=1, ALU=13; SCk; if BRS d_odd else d_even
38. d_odd: MemRead, A=10, B=23, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
39. MemRead, A=9, B=22, AMux=1, CSMux=1, ALU=2, CMux=1, MDROMux=0, C=18; LoadCk, MDROCk
//Shared between all "direct" load instructions that need to load the low order even byte of an OS that is not aligned. Stores it in T6
40. d_odd_shared: A=18, B=19, MARMux=1; MARCk
41. MemRead, EOMux=1, AMux=0, ALU=0, CMux=1, C=20; LoadCk
42. MemRead
43. MemRead, MDREMux=0; MDRECk
44. EOMux=0, AMux=0, ALU=0, CMux=1, C=21; LoadCk;  ISD
//Shared between all "direct" load instructions that need to load an entire aligned word into T6
45. d_even: MemRead
46. MemRead, MDREMux=0, MDROMux=0; MDRECk, MDROCk
47. EOMux=0, AMux=0, ALU=0, CMux=1, C=20; LoadCk
48. EOMux=1, AMux=0, ALU=0, CMux=1, C=21; LoadCk; ISD

//Add Sp to OprSpec, and store it in t5 before branching to shared fetch code
49. sAddr: A=10, B=5, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
50. A=9, B=4, AMux=1, CSMux=1, ALU=2, CMux=1, C=18; LoadCk; goto sx_shared

//Add X to OprSpec, and store it in t5 before branching to shared fetch code
51. xAddr: A=10, B=3, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
52. A=9, B=2, AMux=1, CSMux=1, ALU=2, CMux=1, C=18; LoadCk; goto sx_shared

//Add Sp to OprSpec and X, and store it in t5 before branching to shared fetch code
53. sxAddr: A=10, B=5, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
54. A=9, B=4, AMux=1, CSMux=1, ALU=2, CMux=1, C=18; LoadCk
55. A=19, B=3, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
56. A=18, B=2, AMux=1, CSMux=1, ALU=2, CMux=1, C=18; LoadCk

//Use the shared code for d_even
//otherwise fetch the first byte for an odd operand
57. sx_shared: A=18, B=19, MARMux=1; MARCk
58. MemRead, A=19, AMux=1, ALU=13; SCk; if BRS sx_odd else d_even
59. sx_odd: MemRead, A=19, B=23, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
60. MemRead, A=18, B=22, AMux=1, CSMux=1, ALU=2, CMux=1, MDROMux=0, C=18; LoadCk, MDROCk; goto d_odd_shared
//And then used shared odd code

//Indirect Addressing Modes (N, SF)
61. nAddr: A=9, B=10, MARMux=1; MARCk
62. MemRead, A=10, AMux=1, ALU=13; SCk; if BRS n1_odd else n1_even

//Do the first of two memread
63. n1_even: MemRead
64. MemRead, MDREMux=0, MDROMux=0; MDRECk, MDROCk
65. MARMux=0, EOMux=1, AMux=0, ALU=13; SCk, MARCk
//If the value fetched was even, then the last fetch is identical to d's fetch
//Otherwise, we need to set up the values in t5 so as to use the shared code
66. MemRead; if BRS n2_odd else d_even

//Fetch the next byte, and calculate the value of the next address in t5 (oprSpec+1)
67. n1_odd: MemRead, A=10, B=23, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
68. MemRead, A=9, B=22, AMux=1, CSMux=1, ALU=2, CMux=1, MDROMux=0, C=18; LoadCk, MDROCk
69. n1_odd_shared: A=18, B=19, MARMux=1; MARCk
//Move the odd byte to the high order of t5
70. MemRead, EOMux=1, AMux=0, ALU=0, CMux=1, C=18; LoadCk
71. MemRead
72. MemRead, MDREMux=0; MDRECk
//Move the even byte to the low order of t5
73. EOMux=0, AMux=0, ALU=0, CMux=1, C=19; LoadCk
74. A=18, B=19, MARMux=1; MARCk
//If the address fetched was even, then the last fetch is identical to d's fetch
//Otherwise, we need to set up the values in t5 so as to use the shared code
75. MemRead, A=19, AMux=1, ALU=13; SCk; if BRS n2_odd else d_even

76. n2_odd: MemRead, A=19, B=23, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
//Now that t5 contains the address of the next byte, branch to the shared odd code
77. MemRead, A=18, B=22, AMux=1, CSMux=1, ALU=2, CMux=1, MDROMux=0, C=18; LoadCk, MDROCk; goto d_odd_shared

//Stack-deFerred
//Calculate SP+OprSpec and store it in t5
78. sfAddr: A=10, B=5, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
79. A=9, B=4, AMux=1, CSMux=1, ALU=2, CMux=1, C=18; LoadCk
80. A=18, B=19, MARMux=1; MARCk
//Initiate MemRead, and branch to n1_even if the address is even, as n and sf are indentical from here
81. MemRead, A=19, AMux=1, ALU=13; SCk; if BRS sf_odd else n1_even
//However, for an odd instruction, we need to calculate the next address and store it in t5
//before moving over to n1_odd
82. sf_odd: MemRead, A=19, B=23, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
83. MemRead, A=18, B=22, AMux=1, CSMux=1, ALU=2, CMux=1, MDROMux=0, C=18; LoadCk, MDROCk; goto n1_odd_shared


//Stack-deFerred-indeXed
//First, calculate Sp+OprSpec and stick it in t5
84. sfxAddr: A=10, B=5, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
85. A=9, B=4, AMux=1, CSMux=1, ALU=2, CMux=1, C=18; LoadCk
86. A=18, B=19, MARMux=1; MARCk
87. MemRead, A=19, AMux=1, ALU=13; SCk; if BRS sfx1_odd else sfx1_even
88. sfx1_even: MemRead
89. MemRead, MDREMux=0, MDROMux=0; MDRECk, MDROCk
90. B=3, EOMux=1, AMux=0, ALU=1, CMux=1, C=19; SCk, LoadCk
91. B=2, EOMux=0, AMux=0, CSMux=1, ALU=2, CMux=1, C=18; LoadCk; goto sfx1_shared
92. sfx1_odd: MemRead, A=19, B=23, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
93. MemRead, A=18, B=22, AMux=1, CSMux=1, ALU=2, CMux=1, MDROMux=0, C=18; LoadCk, MDROCk
94. A=18, B=19, MARMux=1; MARCk
95. MemRead
96. MemRead
97. MemRead, MDREMux=0; MDRECk
98. B=3, EOMux=0, AMux=0, ALU=1, CMux=1, C=19; SCk, LoadCk
99. B=2, EOMux=1, AMux=0, CSMux=1, ALU=2, CMux=1, C=18; LoadCk
100. sfx1_shared: A=18, B=19, MARMux=1; MARCk
101. MemRead, A=19, AMux=1, ALU=13; SCk; if BRS sfx2_odd else d_even
102. sfx2_odd: MemRead, A=19, B=23, AMux=1, ALU=1, CMux=1, C=19; SCk, LoadCk
103. MemRead, A=18, B=22, AMux=1, CSMux=1, ALU=2, CMux=1, MDROMux=0, C=18; LoadCk, MDROCk; goto d_odd_shared


//*****************
//
// Instruction implementation
//
//*****************


//Assorted unary instructions
104. stop:	stop
105. movspa:	a=5, c=1, amux=1, alu=0, cmux=1; loadck
106. 		a=1, c=0, amux=1, alu=0, cmux=1; loadck; goto start
107. movflga:a=22, c=0, alu=0, cmux=1; loadck
108. 		c=1, cmux=0; loadck; goto start 
109. movaflg:a=1, amux=1, alu=15, andz=0; Nck, Zck, Vck, Cck; goto start
110. nop0: a=5; goto start 

//Unary logical instructions
111. nota:	a=1, c=1, amux=1, alu=10, cmux=1, andz=0; Zck, Loadck
112. 		a=0, c=0, amux=1, alu=10, cmux=1, andz=1; Nck, Zck, Loadck; goto start
113. notx: 	a=3, c=3, amux=1, alu=10, cmux=1, andz=0; Zck, Loadck
114. 		a=2, c=2, amux=1, alu=10, cmux=1, andz=1; Nck, Zck, Loadck; goto start
115. nega: 	a=1, b=23, c=1, amux=1, alu=3, cmux=1, andz=0; Zck, Sck, Loadck
116. 		a=0, b=22, c=0, amux=1, alu=4, Csmux=1, cmux=1, andz=0; Nck, Zck, Vck, Loadck; goto start
117. negx:	a=3, b=23, c=3, amux=1, alu=3, cmux=1, andz=0; Zck, Sck, Loadck
118. 		a=2, b=22, c=2, amux=1, alu=4, Csmux=1, cmux=1, andz=0; Nck, Zck, Vck, Loadck; goto start

//Unary shift instructions
119. asla: 	a=1, c=1, amux=1, alu=11, cmux=1, andz=0; Zck, Sck, loadck
120. 		a=0, c=0, amux=1, alu=12, csmux=1, cmux=1, andz=1; Zck, Nck, Vck, CCk, Loadck; goto start
121. aslx:	a=3, c=3, amux=1, alu=11, cmux=1, andz=0; Zck, Sck, loadck
122. 		a=2, c=2, amux=1, alu=12, csmux=1, cmux=1, andz=1; Zck, Nck, Vck, CCk, Loadck; goto start
123. asra:	a=0, c=0, amux=1, alu=13, cmux=1, andz=0; Nck, Zck, Sck, Loadck 
124. 		a=1, c=1, amux=1, alu=14, csmux=1, cmux=1, andz=1; Zck, Cck, Loadck; goto start 
125. asrx:	a=2, c=2, amux=1, alu=13, cmux=1, andz=0; Nck, Zck, Sck, Loadck
126. 		a=3, c=3, amux=1, alu=14, csmux=1, cmux=1, andz=1; Zck, Cck, Loadck; goto start
127. rola: 	a=1, c=1, amux=1, alu=12, cmux=1, csmux=0; SCk, loadck
128. 		a=0, c=0, amux=1, alu=12, cmux=1, csmux=1; CCk, loadck; goto start
129. rolx:	a=3, c=3, amux=1, alu=12, cmux=1, csmux=0; SCk, loadck
130. 		a=2, c=2, amux=1, alu=12, cmux=1, csmux=1; CCk, loadck; goto start
131. rora:	a=0, c=0, amux=1, alu=14, csmux=0, cmux=1; SCk, loadck
132. 		a=1, c=1, amux=1, alu=14, csmux=1, cmux=1; CCk, loadck; goto start
133. rorx:	a=2, c=2, amux=1, alu=14, csmux=0, cmux=1; SCk, loadck
134. 		a=3, c=3, amux=1, alu=14, csmux=1, cmux=1; CCk, loadck; goto start

//Non-unary branch instructions
135. br:		a=21, c=7, amux=1, alu=0, cmux=1; loadck
136. 		a=20, c=6, amux=1, alu=0, cmux=1; loadck; goto start
137. brle: 	if brle br else start 
138. brlt: 	if brlt br else start
139. breq:	if breq br else start
140. brne:	if brne br else start
141. brge:	if brge br else start
142. brgt:	if brgt br else start
143. brv:	if brv br else start
144. brc:	if brc br else start

//Non-unary math instructions
145. addsp:	a=5, b=21, c=5, amux=1, alu=1, cmux=1, andz=0; Zck, loadck, sck
146. 		a=4, b=20, c=4, amux=1, alu=2, csmux=1, cmux=1, andz=1; nck, zck, vck, cck, loadck; goto start
147. subsp:	a=5, b=21, c=5, amux=1, alu=3, cmux=1, andz=0; Zck, loadck, sck
148. 		a=4, b=20, c=4, amux=1, alu=4, csmux=1, cmux=1, andz=1; nck, zck, vck, cck, loadck; goto start
		
149. adda: 	a=1, b=21, c=1, amux=1, alu=1, cmux=1, andz=0; Zck, loadck, sck
150. 		a=0, b=20, c=0, amux=1, alu=2, csmux=1, cmux=1, andz=1; nck, zck, vck, cck, loadck; goto start
151. addx:	a=3, b=21, c=3, amux=1, alu=1, cmux=1, andz=0; Zck, loadck, sck
152. 		a=2, b=20, c=2, amux=1, alu=2, csmux=1, cmux=1, andz=1; nck, zck, vck, cck, loadck; goto start
153. suba: 	a=1, b=21, c=1, amux=1, alu=3, cmux=1, andz=0; Zck, loadck, sck
154. 		a=0, b=20, c=0, amux=1, alu=4, csmux=1, cmux=1, andz=1; nck, zck, vck, cck, loadck; goto start
155. subx:	a=3, b=21, c=3, amux=1, alu=3, cmux=1, andz=0; Zck, loadck, sck
156. 		a=2, b=20, c=2, amux=1, alu=4, csmux=1, cmux=1, andz=1; nck, zck, vck, cck, loadck; goto start

//Non-unary logical instructions
157. anda:	a=1, b=21, c=1, amux=1, alu=5, cmux=1, andz=0; Zck, loadck
158. 		a=0, b=20, c=0, amux=1, alu=5, cmux=1, andz=1; Nck, Zck, loadck; goto start
159. andx:	a=3, b=21, c=3, amux=1, alu=5, cmux=1, andz=0; Zck, loadck
160. 		a=2, b=20, c=2, amux=1, alu=5, cmux=1, andz=1; Nck, Zck, loadck; goto start
161. ora:	a=1, b=21, c=1, amux=1, alu=7, cmux=1, andz=0; Zck, loadck
162. 		a=0, b=20, c=0, amux=1, alu=7, cmux=1, andz=1; Nck, Zck, loadck; goto start
163. orx:	a=3, b=21, c=3, amux=1, alu=7, cmux=1, andz=0; Zck, loadck
164. 		a=2, b=20, c=2, amux=1, alu=7, cmux=1, andz=1; Nck, Zck, loadck; goto start

//Non-unary Comparison instructions
165. cpwa: 	a=1, b=21, c=15, amux=1, alu=3, cmux=1, andz=0; Zck, loadck, sck
166. 		a=0, b=20, c=14, amux=1, alu=4, csmux=1, cmux=1, andz=1; nck, zck, vck, cck, loadck; goto start
167. cpwx:	a=3, b=21, c=15, amux=1, alu=3, cmux=1, andz=0; Zck, loadck, sck
168. 		a=2, b=20, c=14, amux=1, alu=4, csmux=1, cmux=1, andz=1; nck, zck, vck, cck, loadck; goto start
169. cpba: 	a=1, b=21, c=15, amux=1, alu=3, cmux=1, andz=0; nck, zck, vck, cck, loadck; goto start
170. cpbx: 	a=3, b=21, c=15, amux=1, alu=3, cmux=1, andz=0; nck, zck, vck, cck, loadck; goto start

//Load  instructions
171. ldba: 	a=21, c=1, amux=1, alu=0, cmux=1, andz=0; Nck, Zck, loadck; goto start
172. ldbx:	a=21, c=3, amux=1, alu=0, cmux=1, andz=0; Nck, Zck, loadck; goto start
173. ldwa:	a=21, c=1, amux=1, alu=0, cmux=1, andz=0; Zck, loadck
174. 		a=20, c=0, amux=1, alu=0, cmux=1, andz=1; Nck, Zck, loadck; goto start
175. ldwx:	a=21, c=3, amux=1, alu=0, cmux=1, andz=0; Zck, loadck
176. 		a=20, c=2, amux=1, alu=0, cmux=1, andz=1; Nck, Zck, loadck; goto start
		
		
//Store byte instructions
177. stba: 	a=20, b=21, marmux=1; marck
178. 		memread, a=21, alu=13; sck; if brs stba_o else stba_e
179. stba_o: memread, a=1, amux=1, alu=0, cmux=1, mdromux=1; mdrock; goto stbr_o
180. stba_e:	memread, a=1, amux=1, alu=0, cmux=1, mdremux=1; mdreck; goto stbr_e

181. sbtx:	a=20, b=21, marmux=1; marck
182. 		memread, a=21, alu=13; sck; if brs stbx_o else stbx_e
183. stbx_o: memread, a=3, amux=1, alu=0, cmux=1, mdromux=1; mdrock; goto stbr_o
184. stbx_e:	memread, a=3, amux=1, alu=0, cmux=1, mdremux=1; mdreck; goto stbr_e

//Shared store byte ode
185. stbr_o: memread, mdremux=0; mdreck; goto mwrte
186. stbr_e: memread, mdromux=0; mdrock; goto mwrte
187. mwrte: 	memwrite
188. 		memwrite
189. mwrte3:	memwrite; goto start
		
//Store word instructions
//First thing, determine if taking even or odd path
190. stwa: 	a=21, amux=1, alu=13; Sck; if brs stwa_o else stwa_e
//Put the next address in [18-19] and the next data in [17]
191. stwa_o: memread, a=21, b=23, c=19, amux=1, alu=1, cmux=1; Sck, loadck
192. 		memread, a=20, b=22, c=18, amux=1, alu=2, csmux=1, cmux=1; loadck
193. 		memread, a=1, amux=1, alu=0, cmux=1, mdremux=0, mdromux=1; mdreck, mdrock
194. 		memwrite, a=0,c=17, alu=0, cmux=1;loadck; goto stwr_o 
195. stwa_e:	memwrite, a=1, amux=1, alu=0, cmux=1, mdromux=1; mdrock
196. 		memwrite, a=0, amux=1, alu=0, cmux=1, mdremux=1; mdreck; goto mwrte3
197. stwx: 	a=21, amux=1, alu=13; Sck; if brs stwx_o else stwx_e
//Put the next address in [18-19] and the next data in [17]
198. stwx_o: memread, a=21, b=23, c=19, amux=1, alu=1, cmux=1; Sck, loadck
199. 		memread, a=20, b=22, c=18, amux=1, alu=2, csmux=1, cmux=1; loadck
200. 		memread, a=3, amux=1, alu=0, cmux=1, mdremux=0, mdromux=1; mdreck, mdrock
201. 		memwrite, a=2,c=17, alu=0, cmux=1;loadck; goto stwr_o
202. stwx_e:	memwrite, a=3, amux=1, alu=0, cmux=1, mdromux=1; mdrock
203. 		memwrite, a=2, amux=1, alu=0, cmux=1, mdremux=1; mdreck; goto mwrte3
204. stwr_o:	memwrite
205. 		memwrite
206. 		a=18, b=19, marmux=1; marck
207. 		memread, a=17, amux=1, alu=0, cmux=1, mdremux=1; mdreck
208. 		memread
209. 		memread, mdromux=0; mdrock; goto mwrte	

		

//Call and return functions



//First determine if SP is even
//If even, then take the aligned path
//Otherwise, take the unaligned path
210. call: 	a=4, b=5, marmux=1; marck
211. 		a=5, amux=1, alu=13; Sck; if brs call_o else call_e
212. call_o:	memread, a=5, b=23, c=19, amux=1, alu=1, cmux=1; Sck, loadck
213. 		memread, a=4, b=22, c=18, amux=1, alu=2, csmux=1, cmux=1; loadck
214. 		memread, a=7, amux=1, alu=0, cmux=1, mdremux=0, mdromux=1; mdreck, mdrock
215. 		memwrite, a=6,c=17, alu=0, cmux=1;loadck 
216. 		memwrite, a=5, b=24, c=5, amux=1, alu=3, cmux=1; Sck, loadck
217. 		memwrite, a=4, b=22, c=4, amux=1, alu=4, csmux=1, cmux=1; loadck
218. 		a=18, b=19, marmux=1; marck
219. 		memread, a=21, c=7, amux=1, alu=0, cmux=1; loadck
220. 		memread, a=20, c=6, amux=1, alu=0, cmux=1; loadck
221. 		memread, a=17, amux=1, alu=0, cmux=1, mdremux=1, mdromux=0; mdreck, mdrock; goto mwrte	
222. call_e:	memwrite, a=7, amux=1, alu=0, mdromux=1; mdrock
223. 		memwrite, a=6, amux=1, alu=0, mdremux=1; mdreck
224. 		memwrite, a=5, b=24, c=5, amux=1, alu=3, cmux=1; Sck, loadck
225. 		a=4, b=22, c=4, amux=1, alu=4, csmux=1, cmux=1; loadck
226. 		a=21, c=7, amux=1, alu=0, cmux=1; loadck
227. 		a=20, c=6, amux=1, alu=0, cmux=1; loadck

//This one is really really bad if unaligned
228. ret: 	a=4, b=5, marmux=1; marck
229. 		a=5, amux=1, alu=13; Sck; if brs ret_o else ret_e
230. ret_o:	memread, a=5, b=23, c=17, amux=1, alu=1, cmux=1; Sck, loadck 
231. 		memread, a=4, b=22, c=16, amux=1, alu=2, csmux=1, cmux=1; loadck 
232. 		memread, mdromux=0; mdrock
233. 		a=16, b=17, marmux=1; marck
234. 		memread, eomux=1, amux=0, alu=0, cmux=1, c=6; loadck
235. 		memread, a=17, b=23, c=5, amux=1, alu=1, cmux=1; Sck, loadck 
236. 		memread, mdremux=0, a=16, b=22, c=4, amux=1, alu=2, csmux=1, cmux=1; loadck, mdreck
237. 		eomux=0, amux=0, alu=0, cmux=1, c=6; loadck
238. ret_e:	memread, a=7, b=24, c=7, amux=1, alu=1, cmux=1; SCk, loadck 
239. 		memread, a=6, b=22, c=6, amux=1, alu=2, csmux=1, cmux=1; SCk 
240. 		memread, mdremux=0, mdromux=0; mdreck, mdrock
241. 		eomux=0, amux=0, alu=0, cmux=1, c=6; loadck
242. 		eomux=1, amux=0, alu=0, cmux=1, c=7; loadck
//TODO		
243. rettr: 	stop //Don't bother with traps for now


//trap instructions
244. nop1: a=5; goto trap
245. nop: a=5; goto trap
246. deci: a=5; goto trap
247. deco: a=5; goto trap
248. hexo: a=5; goto trap
249. stro: a=5; goto trap
250. trap: stop //Don't bother with traps for now